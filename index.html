
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1">
    <title>Painting by Clojure - Tom Booth</title>
    <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link rel="stylesheet" href="/assets/css/bundle.css" type="text/css" media="screen" charset="utf-8">
    <link rel="stylesheet" href="code.css" type="text/css" media="screen" charset="utf-8">
  </head>
  <body>
    <header>
      <h1>Painting by Clojure<small>by <a href="/">Tom Booth</a></small></h1>
    </header>
    <main>
<p>Learning Clojure by build a digital Jackson Pollock.</p>
<canvas id="pollock"></canvas>
<button id="add">
Add stroke
</button>
<button id="fill">
Fill canvas
</button>


<p>Dimensions of space</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> space </span>[<span class="dv">8</span>   <span class="co">;; width</span>
            <span class="dv">5</span>   <span class="co">;; height</span>
            <span class="dv">6</span>]) <span class="co">;; depth</span>

(<span class="kw">def</span><span class="fu"> pixels-per-metre </span><span class="dv">100</span>)</code></pre>
<p>How would you convert from metres to pixels?</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> metres-to-pixels </span>[metres]
  (<span class="kw">*</span> metres pixels-per-metre))</code></pre>
<p>Mainly want to be working in pixels so store the space in pixels</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> space-in-pixels </span>(<span class="kw">map</span> metres-to-pixels space))</code></pre>
<p>We need to pick a place to start the stroke. It will be somewhere inside of the space</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> starting-point </span>[]
  (<span class="kw">let</span> [[width height depth] space]
    [(<span class="kw">rand</span> width)
     (<span class="kw">rand</span> height)
     (<span class="kw">rand</span> depth)]))
</code></pre>
<p>To start off with lets assume that the paint is falling and has 0 velocity of its own when it starts from the brush</p>
<p>We need to know gravity, measured in metres per second</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> gravity </span>[<span class="dv">0</span> -<span class="fl">9.8</span> <span class="dv">0</span>])
</code></pre>
<p>we need to know the amount of time it is going to take the paint to fall, which we can work out based on the y dimension alone</p>
<p>we know the initial position and velocity, final position and acceleration and we need to find the time. We cant use the equation r = r0 + v0 * t + at^2/2 we need to use the quadratic equation to solve for t rearranged we get at^2 + 2v0t + 2r0 - 2r = 0 in quad equation: a = a b = 2v0 c = 2r0 - 2r r (final position) is always going to be 0 so, c = 2r0</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> time-to-canvas </span>[position velocity acceleration]
  (<span class="kw">let</span> [a acceleration
        b (<span class="kw">*</span> <span class="dv">2</span> velocity)
        c (<span class="kw">*</span> <span class="dv">2</span> position)
        discriminant (<span class="kw">-</span> (<span class="kw">*</span> b b) (<span class="kw">*</span> <span class="dv">4</span> a c))
        minus-b (<span class="kw">-</span> <span class="dv">0</span> b)
        add-sqrt (<span class="kw">/</span> (<span class="kw">+</span> minus-b (Math/sqrt discriminant)) (<span class="kw">*</span> <span class="dv">2</span> a))
        minus-sqrt (<span class="kw">/</span> (<span class="kw">-</span> minus-b (Math/sqrt discriminant)) (<span class="kw">*</span> <span class="dv">2</span> a))]
    (<span class="kw">max</span> add-sqrt minus-sqrt)))</code></pre>
<p>now we can get the time we need to be able to derive the final velocity and position of any dimension</p>
<p>v = at + v0</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> velocity-at </span>[<span class="kw">time</span> initial-velocity acceleration]
  (<span class="kw">+</span> (<span class="kw">*</span> acceleration <span class="kw">time</span>) initial-velocity))</code></pre>
<p>for position we can use the same equation we used to derive the time</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> position-at </span>[<span class="kw">time</span> initial-position initial-velocity acceleration]
  (<span class="kw">+</span> initial-position
     (<span class="kw">*</span> initial-velocity <span class="kw">time</span>)
     (<span class="kw">/</span> (<span class="kw">*</span> acceleration <span class="kw">time</span> <span class="kw">time</span>) <span class="dv">2</span>)))</code></pre>
<p>we can now link these up into a function to get the final position and velocity for a point</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> project-point </span>[position velocity]
  (<span class="kw">let</span> [[i j k]            position
        [vi vj vk]         velocity
        [ai aj ak]         gravity
        
        <span class="kw">time</span>               (time-to-canvas j vj aj)
        
        projected-position [(position-at <span class="kw">time</span> i vi ai)
                            <span class="dv">0</span>  <span class="co">;; we don&#39;t need to calculate as it</span>
                               <span class="co">;; should be 0, on the canvas</span>
                            (position-at <span class="kw">time</span> k vk ak)]
        
        projected-velocity [(velocity-at <span class="kw">time</span> vi ai)
                            (velocity-at <span class="kw">time</span> vj aj)
                            (velocity-at <span class="kw">time</span> vk ak)]]
    [projected-position
     projected-velocity]))
</code></pre>
<p>splatter now that we know the impact velocity of a point, we know need to work out whether that impact should splatter</p>
<p>we need to work out the impact force as a scalar so that we can define a cut off</p>
<p>this will require working out the absolute value of a vector. We do this by summing up the squares of the dimensions and then taking th root</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> vector-absolute </span>[<span class="kw">vector</span>]
  (Math/sqrt (<span class="kw">reduce</span> <span class="kw">+</span> (<span class="kw">map</span> #(<span class="kw">*</span> % %) <span class="kw">vector</span>))))</code></pre>
<p>need something about why it is ok this is velocity and not acceleration, maybe because it is the relative acceleration of the imapct of the two objects (paint has velocity, cavnas doesn't so accel = velocity?)</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> impact-force </span>[mass velocity]
  (<span class="kw">*</span> (vector-absolute velocity) mass))</code></pre>
<p>we need to work out if an impact should splatter off some of its paint. This should include some randomess as it is likely a consecutive points will all splatter and including some randomness will make it look at little less 'generated'</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> min-impact-force-for-splatter </span><span class="dv">50</span>)

(<span class="kw">defn</span><span class="fu"> does-impact-splatter</span>? [mass velocity]
  (<span class="kw">and</span> (<span class="kw">&gt;</span> (impact-force mass velocity) min-impact-force-for-splatter)
       (<span class="kw">&gt;</span> (<span class="kw">rand</span>) <span class="fl">0.8</span>)))</code></pre>
<p>if an impact splatters then we will need to bounce its velocity vector as this is the direction it will exit its current position</p>
<p>the equation to bounce a vector, V, off a plane with normal, N, is: needs rewriting http://mathworld.wolfram.com/Reflection.html</p>
<p>N is the normal vector of the plane R is the reflected vector</p>
<p>R = V - (2 * (V.N) * N)</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> canvas-normal </span>[<span class="dv">0</span> <span class="dv">1</span> <span class="dv">0</span>])</code></pre>
<p>dot product is he sum of the multiples of the dimensions</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> dot-product </span>[vector1 vector2]
  (<span class="kw">reduce</span> <span class="kw">+</span> (<span class="kw">map</span> <span class="kw">*</span> vector1 vector2)))

(<span class="kw">defn</span><span class="fu"> vector-subtraction </span>[vector1 vector2]
  (<span class="kw">map</span> <span class="kw">-</span> vector1 vector2))

(<span class="kw">defn</span><span class="fu"> vector-multiply-by-constant </span>[<span class="kw">vector</span> constant]
  (<span class="kw">map</span> #(<span class="kw">*</span> % constant) <span class="kw">vector</span>))
</code></pre>
<p>blah? need a better name for this variable</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> bounce-vector </span>[<span class="kw">vector</span> normal]
  (<span class="kw">let</span> [vector-dot-normal (dot-product <span class="kw">vector</span> normal)
        blah (vector-multiply-by-constant normal (<span class="kw">*</span> <span class="dv">2</span> vector-dot-normal))]
    (vector-subtraction <span class="kw">vector</span> blah)))
</code></pre>
<p>splatter will never take all of the paint and velocity with it so we need a dampening constant</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> splatter-dampening-constant </span><span class="fl">0.7</span>)

(<span class="kw">defn</span><span class="fu"> splatter-vector </span>[velocity]
  (<span class="kw">let</span> [bounced-vector (bounce-vector velocity canvas-normal)]
    (vector-multiply-by-constant bounced-vector
                                 splatter-dampening-constant)))
</code></pre>
<p>doing paths having all the code for dealing with a point is all well and good, but we need to be dealing with paths</p>
<p>I've had a play with path generation before and besier curves gave a nice output</p>
<p>De Casteljau's algorithm is the way we shall be coming up with paths</p>
<p>first off we need to generate the anchor points for the curve</p>
<p>to do this we will need to be able to: - get a random number between two points (for distance, steps) - get a random direction - add vectors</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> random-between </span>[lower-bound upper-bound]
  (<span class="kw">+</span> lower-bound (<span class="kw">rand</span> (<span class="kw">-</span> upper-bound lower-bound))))</code></pre>
<p>need some blurb about this algo, hopefully find something from the asimuth</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> random-unit-vector </span>[]
  (<span class="kw">let</span> [asimuth (<span class="kw">*</span> (<span class="kw">rand</span>) <span class="dv">2</span> Math/PI)
        k (<span class="kw">-</span> (<span class="kw">rand</span> <span class="dv">2</span>) <span class="dv">1</span>)
        a (Math/sqrt (<span class="kw">-</span> <span class="dv">1</span> (<span class="kw">*</span> k k)))
        i (<span class="kw">*</span> (Math/cos asimuth) a)
        j (<span class="kw">*</span> (Math/sin asimuth) a)]
    [i j k]))

(<span class="kw">defn</span><span class="fu"> vector-add </span>[vector1 vector2]
  (<span class="kw">map</span> <span class="kw">+</span> vector1 vector2))</code></pre>
<p>need to walk between a start and end position in a random fashion</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> random-vector-between </span>[lower upper]
  [(random-between lower upper)
   (random-between lower upper)
   (random-between lower upper)])

(<span class="kw">defn</span><span class="fu"> random-path </span>[position step-vector bounds]
  (<span class="kw">cons</span> position
        (<span class="kw">lazy-seq</span> (random-path (vector-add (vector-add position step-vector)
                                           (random-vector-between (<span class="kw">-</span> <span class="dv">0</span> bounds) bounds))
                               step-vector bounds))))</code></pre>
<p>what is an anchor point for a bezier curve? added min/max steps to try and guide whether this is a flick, as well as the variation in random positions</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> anchor-points </span>[position min-distance max-distance min-steps max-steps variation]
  (<span class="kw">let</span> [direction       (random-unit-vector)
        distance        (random-between min-distance max-distance)
        steps           (random-between min-steps max-steps)
        step-vector     (vector-multiply-by-constant direction (<span class="kw">/</span> distance steps))
        random-positions (<span class="kw">take</span> steps (random-path position step-vector variation))
        end-position    (vector-add position
                                    (vector-multiply-by-constant step-vector steps))]
    (<span class="kw">conj</span> (<span class="kw">vec</span> random-positions) end-position)))
</code></pre>
<p>de casteljau code ripped from pollock, needs a REWRITE and a whole bunch of explanation</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> recur-relation </span>[t a b]
  (<span class="kw">+</span> (<span class="kw">*</span> t b) (<span class="kw">*</span> a (<span class="kw">-</span> <span class="dv">1</span> t))))

(<span class="kw">defn</span><span class="fu"> for-component </span>[t component-vals]
  (<span class="kw">if</span> (<span class="kw">=</span> (<span class="kw">count</span> component-vals) <span class="dv">1</span>)
    (<span class="kw">first</span> component-vals)
    (for-component t
      (<span class="kw">map</span> #(recur-relation t %<span class="dv">1</span> %<span class="dv">2</span>) component-vals (<span class="kw">rest</span> component-vals)))))

(<span class="kw">defn</span><span class="fu"> for-t </span>[t components]
  (<span class="kw">map</span> #(for-component t %) components))

(<span class="kw">defn</span><span class="fu"> de-casteljau </span>[control-points step-amount]
  (<span class="kw">let</span> [x-vals (<span class="kw">map</span> <span class="kw">first</span> control-points)
        y-vals (<span class="kw">map</span> <span class="kw">second</span> control-points)
        z-vals (<span class="kw">map</span> #(<span class="kw">nth</span> % <span class="dv">2</span>) control-points)
        points (<span class="kw">map</span> #(for-t % [x-vals y-vals z-vals]) (<span class="kw">range</span> <span class="dv">0</span> <span class="dv">1</span> step-amount))]
    points))</code></pre>
<p>this can generate paths that go below the canvas, we should set these to 0 as it is the equivalent of painting on the canvas</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> ensure-above-canvas </span>[<span class="kw">path</span>]
  (<span class="kw">map</span> (<span class="kw">fn</span> [[i j k]] [i (<span class="kw">if</span> (<span class="kw">&lt;</span> j <span class="dv">0</span>) <span class="dv">0</span> j) k]) <span class="kw">path</span>))
</code></pre>
<p>all the points along the generated path should have an associated velocity. To start with we can generate a linear velocity along the path, given a randomised total time to traverse the path and the total length of the path.</p>
<p>In order to calculate the length of the paths, we will want to do something similar to a map but with pairs of values. Using this we can take two points, calculate the distance between them and then sum all the distances</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> map-2 </span>[f coll]
  (<span class="kw">when-let</span> [s (<span class="kw">seq</span> coll)]
    (<span class="kw">let</span> [s1 (<span class="kw">first</span> s)
          s2 (<span class="kw">second</span> s)]
      (<span class="kw">if</span> (<span class="kw">not</span> (<span class="kw">nil?</span> s2))
        (<span class="kw">cons</span> (f (<span class="kw">first</span> s) (<span class="kw">second</span> s)) (map<span class="dv">-2</span> f (<span class="kw">rest</span> s)))))))</code></pre>
<p>in order to find the distance between two points we need subtract the two vectors, square and sum the resultant dimensions and then take the root. (https://en.wikipedia.org/wiki/Euclidean_distance)</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> vector-multiply </span>[vector1 vector2]
  (<span class="kw">map</span> <span class="kw">*</span> vector1 vector2))

(<span class="kw">defn</span><span class="fu"> distance-between-points </span>[point1 point2]
  (<span class="kw">let</span> [difference-vector (vector-subtraction point1 point2)
        summed-vector (<span class="kw">reduce</span> <span class="kw">+</span> (vector-multiply difference-vector difference-vector))]
    (Math/sqrt summed-vector)))

(<span class="kw">defn</span><span class="fu"> path-length </span>[<span class="kw">path</span>]
  (<span class="kw">reduce</span> <span class="kw">+</span> (map<span class="dv">-2</span> distance-between-points <span class="kw">path</span>)))


(<span class="kw">defn</span><span class="fu"> vector-divide-by-const </span>[<span class="kw">vector</span> const]
  (<span class="kw">map</span> #(<span class="kw">/</span> % const) <span class="kw">vector</span>))

(<span class="kw">defn</span><span class="fu"> velocity-between </span>[point1 point2 total-time total-distance]
  (<span class="kw">let</span> [difference-vector (vector-subtraction point1 point2)
        time-between (<span class="kw">*</span> total-time (<span class="kw">/</span> (distance-between-points point1 point2)
                                      total-distance))]
    (vector-divide-by-const difference-vector time-between)))</code></pre>
<p>this calculation will leave off the last points velocity, so for now we can just set it to 0</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> path-velocities </span>[<span class="kw">path</span> total-time]
  (<span class="kw">let</span> [total-distance   (path-length <span class="kw">path</span>)
        number-of-points (<span class="kw">count</span> <span class="kw">path</span>)]
    (<span class="kw">conj</span> (<span class="kw">vec</span> (map<span class="dv">-2</span> #(velocity-between %<span class="dv">1</span> %<span class="dv">2</span>
                                         total-time
                                         total-distance)
                      <span class="kw">path</span>))
          [<span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span>])))</code></pre>
<p>as well as the velocity at each point along the path, we also need how much paint there is falling. Again to keep life simple we are going to model this as a linear flow along the path with there always being no paint left.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> path-masses </span>[<span class="kw">path</span> initial-mass]
  (<span class="kw">let</span> [number-of-points (<span class="kw">count</span> <span class="kw">path</span>)
        step (<span class="kw">-</span> <span class="dv">0</span> (<span class="kw">/</span> initial-mass number-of-points))]
    (<span class="kw">take</span> number-of-points (<span class="kw">range</span> initial-mass <span class="dv">0</span> step))))
</code></pre>
<p>now we need to assemble all of the above functions into something that will work out everything</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> do-the-things </span>[]
  (<span class="kw">let</span> [position       (starting-point)
        total-time     (random-between <span class="dv">1</span> <span class="dv">5</span>)
        <span class="kw">path</span>           (ensure-above-canvas (de-casteljau (anchor-points position <span class="fl">0.1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">15</span> <span class="fl">0.4</span>) <span class="fl">0.005</span>))
        velocities     (path-velocities <span class="kw">path</span> total-time)
        masses         (path-masses <span class="kw">path</span> (random-between <span class="dv">5</span> <span class="dv">30</span>))
        projected-path (<span class="kw">map</span> #(project-point %<span class="dv">1</span> %<span class="dv">2</span>) <span class="kw">path</span> velocities)
        splatter       (<span class="kw">map</span> (<span class="kw">fn</span> [[position velocity] mass]
                              (<span class="kw">if</span> (does-impact-splatter? mass velocity)
                                [position (splatter-vector velocity) (<span class="kw">*</span> mass splatter-dampening-constant)]
                                nil))
                            projected-path masses)
        projected-splatter (<span class="kw">map</span> (<span class="kw">fn</span> [[position velocity mass <span class="kw">:as</span> point]]
                                  (<span class="kw">if</span> (<span class="kw">nil?</span> point)
                                    nil
                                    (<span class="kw">conj</span> (<span class="kw">vec</span> (project-point position velocity)) mass)))
                                splatter)]
    {<span class="kw">:air</span> <span class="kw">path</span>
     <span class="kw">:path</span> (<span class="kw">map</span> #(<span class="kw">conj</span> %<span class="dv">1</span> %<span class="dv">2</span>) projected-path masses)
     <span class="kw">:splatter</span> (<span class="kw">filter</span> #(<span class="kw">not-any?</span> <span class="kw">nil?</span> %) (partition-by <span class="kw">nil?</span> projected-splatter))}))
</code></pre>
<p>lets draw these things</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> sketch-size</span>
  (<span class="kw">let</span> [[width _ height] space-in-pixels]
    [width height]))

(<span class="kw">defn</span><span class="fu"> position-to-pixel </span>[[i j k]]
  [(Math/floor (metres-to-pixels i))
   (Math/floor (metres-to-pixels k))])


(<span class="kw">defn</span><span class="fu"> draw-path </span>[<span class="kw">path</span>]
  (<span class="kw">doall</span>
   (map<span class="dv">-2</span> (<span class="kw">fn</span> [[position1 _ mass] [position2 _ _]]
            (q/stroke-weight mass)
            (<span class="kw">apply</span> q/line (<span class="kw">concat</span> (position-to-pixel position1) (position-to-pixel position2))))
          <span class="kw">path</span>)))

(<span class="kw">defn</span><span class="fu"> draw-splats </span>[<span class="kw">path</span>]
  (<span class="kw">doall</span> (<span class="kw">map</span> (<span class="kw">fn</span> [[position _ mass]]
                (q/stroke-weight mass)
                (<span class="kw">apply</span> q/point (position-to-pixel position)))
              <span class="kw">path</span>)))

(<span class="kw">defn</span><span class="fu"> make-shape </span>[&amp; any]
  (q/with-sketch (q/get-sketch-by-id <span class="st">&quot;pollock&quot;</span>)
    (<span class="kw">let</span> [{<span class="kw">:keys</span> [<span class="kw">path</span> splatter] <span class="kw">:as</span> path-hash} (do-the-things)]
      (.log js/console (clj-&gt;js path-hash))
      (q/stroke (q/color (<span class="kw">rand-int</span> <span class="dv">256</span>) (<span class="kw">rand-int</span> <span class="dv">256</span>) (<span class="kw">rand-int</span> <span class="dv">256</span>)))
      (draw-path <span class="kw">path</span>)
      (<span class="kw">doall</span> (<span class="kw">map</span> draw-splats splatter)))))

(<span class="kw">defn</span><span class="fu"> draw </span>[]
  (q/background <span class="dv">255</span>)
  (q/fill <span class="dv">0</span>))

(q/defsketch pollock
  <span class="kw">:setup</span> draw
  <span class="kw">:host</span> <span class="st">&quot;pollock&quot;</span>
  <span class="kw">:size</span> sketch-size)

(.addEventListener (.querySelector js/document <span class="st">&quot;#add&quot;</span>)
                   <span class="st">&quot;click&quot;</span>
                   make-shape)

(<span class="kw">def</span><span class="fu"> interval-ref </span>(<span class="kw">atom</span> nil))
(<span class="kw">def</span><span class="fu"> fill-count </span>(<span class="kw">atom</span> <span class="dv">0</span>))
(.addEventListener (.querySelector js/document <span class="st">&quot;#fill&quot;</span>)
                   <span class="st">&quot;click&quot;</span>
                   (<span class="kw">fn</span> [<span class="kw">e</span>]
                     (<span class="kw">reset!</span> interval-ref
                             (js/setInterval (<span class="kw">fn</span> []
                                               (<span class="kw">if</span> (<span class="kw">&gt;</span> <span class="kw">@fill-count</span> <span class="dv">500</span>)
                                                 (js/clearInterval <span class="kw">@interval-ref)</span>
                                                 (<span class="kw">do</span> (make-shape) (<span class="kw">swap!</span> fill-count <span class="kw">inc</span>)))) <span class="dv">100</span>))))</code></pre>
    </main>
    <footer>
      Written with <abbr class="heart" title="love">&#9829;</abbr> by <a href="/">Tom Booth</a>
    </footer>
    <script src="js/processing-1.4.8.js" type="text/javascript" charset="utf-8"></script>
    <script src="js/main.js" type="text/javascript" charset="utf-8"></script>
  </body>
</html>
